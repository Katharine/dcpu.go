package dcpu

import (
	"bytes"
	"testing"
)

// Tests that the sample program at the end of the spec has the expected value when it terminates.
func TestSpecSample(t *testing.T) {
	b := bytes.NewBuffer([]byte{
		0x7c, 0x01, 0x00, 0x30, 0x7d, 0xe1, 0x10, 0x00, 0x00, 0x20, 0x78, 0x03, 0x10, 0x00, 0xc0, 0x0d,
		0x7d, 0xc1, 0x00, 0x1a, 0xa8, 0x61, 0x7c, 0x01, 0x20, 0x00, 0x21, 0x61, 0x20, 0x00, 0x84, 0x63,
		0x80, 0x6d, 0x7d, 0xc1, 0x00, 0x0d, 0x90, 0x31, 0x7c, 0x10, 0x00, 0x18, 0x7d, 0xc1, 0x00, 0x1a,
		0x90, 0x37, 0x61, 0xc1, 0x7d, 0xc1, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	})

	cpu := New()
	if err := cpu.LoadStream(b); err != nil {
		t.Errorf("Loading stream failed: %s", err)
	}

	// Do the run loop ourselves, since we know we're going to hang.
	for i := 0; i < 1000; i++ {
		cpu.ExecuteCycle()
	}

	if cpu.Registers[X] != 0x40 {
		t.Error("X is not 0x40.")
	}
}
